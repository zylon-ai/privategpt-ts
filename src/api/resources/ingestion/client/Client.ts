/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as PrivategptApi from '../../..';
import * as core from '../../../../core';
import * as errors from '../../../../errors';
import * as serializers from '../../../../serialization';

import urlJoin from 'url-join';

export declare namespace Ingestion {
  interface Options {
    environment: core.Supplier<string>;
  }

  interface RequestOptions {
    timeoutInSeconds?: number;
    maxRetries?: number;
  }
}

export class Ingestion {
  constructor(protected readonly _options: Ingestion.Options) {}

  /**
   * Ingests and processes a file.
   *
   * Deprecated. Use ingest/file instead.
   * @throws {@link PrivategptApi.UnprocessableEntityError}
   */
  public async ingest(
    file: File,
    requestOptions?: Ingestion.RequestOptions,
  ): Promise<PrivategptApi.IngestResponse> {
    const _request = new FormData();
    _request.append('file', file);
    const _response = await core.fetcher({
      url: urlJoin(
        await core.Supplier.get(this._options.environment),
        'v1/ingest',
      ),
      method: 'POST',
      headers: {
        'X-Fern-Language': 'JavaScript',
      },
      contentType: 'multipart/form-data; boundary=' + file.size,
      body: _request,
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
    });
    if (_response.ok) {
      return await serializers.IngestResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: 'passthrough',
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true,
        breadcrumbsPrefix: ['response'],
      });
    }

    if (_response.error.reason === 'status-code') {
      switch (_response.error.statusCode) {
        case 422:
          throw new PrivategptApi.UnprocessableEntityError(
            await serializers.HttpValidationError.parseOrThrow(
              _response.error.body,
              {
                unrecognizedObjectKeys: 'passthrough',
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ['response'],
              },
            ),
          );
        default:
          throw new errors.PrivategptApiError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
          });
      }
    }

    switch (_response.error.reason) {
      case 'non-json':
        throw new errors.PrivategptApiError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
        });
      case 'timeout':
        throw new errors.PrivategptApiTimeoutError();
      case 'unknown':
        throw new errors.PrivategptApiError({
          message: _response.error.errorMessage,
        });
    }
  }

  /**
   * Ingests and processes a file, storing its chunks to be used as context.
   *
   * The context obtained from files is later used in
   * `/chat/completions`, `/completions`, and `/chunks` APIs.
   *
   * Most common document
   * formats are supported, but you may be prompted to install an extra dependency to
   * manage a specific file type.
   *
   * A file can generate different Documents (for example a PDF generates one Document
   * per page). All Documents IDs are returned in the response, together with the
   * extracted Metadata (which is later used to improve context retrieval). Those IDs
   * can be used to filter the context used to create responses in
   * `/chat/completions`, `/completions`, and `/chunks` APIs.
   * @throws {@link PrivategptApi.UnprocessableEntityError}
   */
  public async ingestFile(
    file: File,
    requestOptions?: Ingestion.RequestOptions,
  ): Promise<PrivategptApi.IngestResponse> {
    const _request = new FormData();
    _request.append('file', file);
    const _response = await core.fetcher({
      url: urlJoin(
        await core.Supplier.get(this._options.environment),
        'v1/ingest/file',
      ),
      method: 'POST',
      headers: {
        'X-Fern-Language': 'JavaScript',
      },
      // contentType: 'multipart/form-data; boundary=' + _request.getBoundary(),
      body: _request,
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
    });
    if (_response.ok) {
      return await serializers.IngestResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: 'passthrough',
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true,
        breadcrumbsPrefix: ['response'],
      });
    }

    if (_response.error.reason === 'status-code') {
      switch (_response.error.statusCode) {
        case 422:
          throw new PrivategptApi.UnprocessableEntityError(
            await serializers.HttpValidationError.parseOrThrow(
              _response.error.body,
              {
                unrecognizedObjectKeys: 'passthrough',
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ['response'],
              },
            ),
          );
        default:
          throw new errors.PrivategptApiError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
          });
      }
    }

    switch (_response.error.reason) {
      case 'non-json':
        throw new errors.PrivategptApiError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
        });
      case 'timeout':
        throw new errors.PrivategptApiTimeoutError();
      case 'unknown':
        throw new errors.PrivategptApiError({
          message: _response.error.errorMessage,
        });
    }
  }

  /**
   * Ingests and processes a text, storing its chunks to be used as context.
   *
   * The context obtained from files is later used in
   * `/chat/completions`, `/completions`, and `/chunks` APIs.
   *
   * A Document will be generated with the given text. The Document
   * ID is returned in the response, together with the
   * extracted Metadata (which is later used to improve context retrieval). That ID
   * can be used to filter the context used to create responses in
   * `/chat/completions`, `/completions`, and `/chunks` APIs.
   * @throws {@link PrivategptApi.UnprocessableEntityError}
   *
   * @example
   *     await privategptApi.ingestion.ingestText({
   *         fileName: "string",
   *         text: "string"
   *     })
   */
  public async ingestText(
    request: PrivategptApi.IngestTextBody,
    requestOptions?: Ingestion.RequestOptions,
  ): Promise<PrivategptApi.IngestResponse> {
    const _response = await core.fetcher({
      url: urlJoin(
        await core.Supplier.get(this._options.environment),
        'v1/ingest/text',
      ),
      method: 'POST',
      headers: {
        'X-Fern-Language': 'JavaScript',
      },
      contentType: 'application/json',
      body: await serializers.IngestTextBody.jsonOrThrow(request, {
        unrecognizedObjectKeys: 'strip',
      }),
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
    });
    if (_response.ok) {
      return await serializers.IngestResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: 'passthrough',
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true,
        breadcrumbsPrefix: ['response'],
      });
    }

    if (_response.error.reason === 'status-code') {
      switch (_response.error.statusCode) {
        case 422:
          throw new PrivategptApi.UnprocessableEntityError(
            await serializers.HttpValidationError.parseOrThrow(
              _response.error.body,
              {
                unrecognizedObjectKeys: 'passthrough',
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ['response'],
              },
            ),
          );
        default:
          throw new errors.PrivategptApiError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
          });
      }
    }

    switch (_response.error.reason) {
      case 'non-json':
        throw new errors.PrivategptApiError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
        });
      case 'timeout':
        throw new errors.PrivategptApiTimeoutError();
      case 'unknown':
        throw new errors.PrivategptApiError({
          message: _response.error.errorMessage,
        });
    }
  }

  /**
   * Lists already ingested Documents including their Document ID and metadata.
   *
   * Those IDs can be used to filter the context used to create responses
   * in `/chat/completions`, `/completions`, and `/chunks` APIs.
   *
   * @example
   *     await privategptApi.ingestion.listIngested()
   */
  public async listIngested(
    requestOptions?: Ingestion.RequestOptions,
  ): Promise<PrivategptApi.IngestResponse> {
    const _response = await core.fetcher({
      url: urlJoin(
        await core.Supplier.get(this._options.environment),
        'v1/ingest/list',
      ),
      method: 'GET',
      headers: {
        'X-Fern-Language': 'JavaScript',
      },
      contentType: 'application/json',
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
    });
    if (_response.ok) {
      return await serializers.IngestResponse.parseOrThrow(_response.body, {
        unrecognizedObjectKeys: 'passthrough',
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true,
        breadcrumbsPrefix: ['response'],
      });
    }

    if (_response.error.reason === 'status-code') {
      throw new errors.PrivategptApiError({
        statusCode: _response.error.statusCode,
        body: _response.error.body,
      });
    }

    switch (_response.error.reason) {
      case 'non-json':
        throw new errors.PrivategptApiError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
        });
      case 'timeout':
        throw new errors.PrivategptApiTimeoutError();
      case 'unknown':
        throw new errors.PrivategptApiError({
          message: _response.error.errorMessage,
        });
    }
  }

  /**
   * Delete the specified ingested Document.
   *
   * The `doc_id` can be obtained from the `GET /ingest/list` endpoint.
   * The document will be effectively deleted from your storage context.
   * @throws {@link PrivategptApi.UnprocessableEntityError}
   *
   * @example
   *     await privategptApi.ingestion.deleteIngested("string")
   */
  public async deleteIngested(
    docId: string,
    requestOptions?: Ingestion.RequestOptions,
  ): Promise<unknown> {
    const _response = await core.fetcher({
      url: urlJoin(
        await core.Supplier.get(this._options.environment),
        `v1/ingest/${docId}`,
      ),
      method: 'DELETE',
      headers: {
        'X-Fern-Language': 'JavaScript',
      },
      contentType: 'application/json',
      timeoutMs:
        requestOptions?.timeoutInSeconds != null
          ? requestOptions.timeoutInSeconds * 1000
          : 60000,
      maxRetries: requestOptions?.maxRetries,
    });
    if (_response.ok) {
      return _response.body;
    }

    if (_response.error.reason === 'status-code') {
      switch (_response.error.statusCode) {
        case 422:
          throw new PrivategptApi.UnprocessableEntityError(
            await serializers.HttpValidationError.parseOrThrow(
              _response.error.body,
              {
                unrecognizedObjectKeys: 'passthrough',
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ['response'],
              },
            ),
          );
        default:
          throw new errors.PrivategptApiError({
            statusCode: _response.error.statusCode,
            body: _response.error.body,
          });
      }
    }

    switch (_response.error.reason) {
      case 'non-json':
        throw new errors.PrivategptApiError({
          statusCode: _response.error.statusCode,
          body: _response.error.rawBody,
        });
      case 'timeout':
        throw new errors.PrivategptApiTimeoutError();
      case 'unknown':
        throw new errors.PrivategptApiError({
          message: _response.error.errorMessage,
        });
    }
  }
}
